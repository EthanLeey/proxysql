--- libmariadb/mariadb_lib.c	2019-09-03 12:48:10.000000000 +0000
+++ /tmp/mariadb_lib.c	2020-05-20 05:12:53.192791956 +0000
@@ -140,6 +140,7 @@
 static void mysql_close_memory(MYSQL *mysql);
 void read_user_name(char *name);
 my_bool STDCALL mariadb_reconnect(MYSQL *mysql);
+my_bool STDCALL mariadb_redirect(MYSQL* mysql);
 static int cli_report_progress(MYSQL *mysql, uchar *packet, uint length);
 
 extern int mysql_client_plugin_init();
@@ -1515,9 +1516,16 @@
 
   mysql->client_flag= client_flag;
 
+   {
+       volatile my_bool net_blocking = ma_pvio_is_blocking(net->pvio);
+       if (!net_blocking)
+           ma_pvio_blocking(net->pvio, TRUE, 0);
   if (run_plugin_auth(mysql, scramble_data, scramble_len,
                              scramble_plugin, db))
     goto error;
+       if (!net_blocking)
+           ma_pvio_blocking(net->pvio, FALSE, 0);
+   }
 
   if (mysql->client_flag & CLIENT_COMPRESS)
     net->compress= 1;
@@ -1565,9 +1573,23 @@
   /* connection established, apply timeouts */
   ma_pvio_set_timeout(mysql->net.pvio, PVIO_READ_TIMEOUT, mysql->options.read_timeout);
   ma_pvio_set_timeout(mysql->net.pvio, PVIO_WRITE_TIMEOUT, mysql->options.write_timeout);
+  
+  // TODO: remove the following block after implementing it in plugin
+  if (!mariadb_redirect(mysql))
+     goto error;
+
   return(mysql);
 
 error:
+  // fix for proxysql bug #2623
+  if (mysql->net.extension) {
+     free(mysql->net.extension);
+     mysql->net.extension=NULL;
+  }
+  if (mysql->extension) {
+     free(mysql->extension);
+     mysql->extension=NULL;
+  }
   /* Free alloced memory */
   end_server(mysql);
   /* only free the allocated memory, user needs to call mysql_close */
@@ -1647,7 +1669,7 @@
   if (!mysql_real_connect(&tmp_mysql,mysql->host,mysql->user,mysql->passwd,
 			  mysql->db, mysql->port, mysql->unix_socket,
 			  mysql->client_flag | CLIENT_REMEMBER_OPTIONS) ||
-      mysql_set_character_set(&tmp_mysql, mysql->charset->csname))
+      mysql_set_character_set(&tmp_mysql, mysql->charset->csname, 0))
   {
     if (ctxt)
       my_context_install_suspend_resume_hook(ctxt, NULL, NULL);
@@ -1689,10 +1711,140 @@
   return(0);
 }
 
+my_bool STDCALL mariadb_redirect(MYSQL* mysql)
+{
+    if (!mysql->info || !mysql->info[0])
+    {
+        return NULL;
+    }
+
+    char host_str[256] = { 0 };
+    char user_str[256] = { 0 };
+    char port_str[256] = { 0 };
+    int port = 0;
+
+    char* info_str = strtok(mysql->info, "\b");
+    if (strlen(info_str) >= 27 && (strncmp(info_str, "Location:", strlen("Location:")) == 0))
+    {
+        char* p1 = strstr(info_str, "//");
+        char* p2 = strstr(p1, ":");
+        char* p3 = strstr(info_str, "user=");
+        int host_len = p2 - p1 - 2;
+        int port_len = p3 - p2 - 2;
+        int user_len = strlen(info_str) - (p3 + 5 - info_str);
+
+        char* end_of_user = strstr(p3, "\025");
+        if (end_of_user)
+        {
+            user_len -= strlen(end_of_user);
+        }
+
+        if (host_len <= 0 || port_len <= 0 || user_len <= 0)
+        {
+            return NULL;
+        }
+
+        ma_strmake(host_str, p1 + 2, host_len);
+        ma_strmake(user_str, p3 + 5, user_len);
+        ma_strmake(port_str, p2 + 1, port_len);
+
+        if (!(port = strtoul(port_str, NULL, 0)))
+        {
+            return NULL;
+        }
+    }
+
+    MYSQL tmp_mysql;
+    struct my_hook_data hook_data;
+    struct mysql_async_context* ctxt = NULL;
+    LIST* li_stmt = mysql->stmts;
+
+    /* check if connection handler is active */
+    if (IS_CONNHDLR_ACTIVE(mysql))
+    {
+        if (mysql->extension->conn_hdlr->plugin && mysql->extension->conn_hdlr->plugin->reconnect)
+            return(mysql->extension->conn_hdlr->plugin->reconnect(mysql));
+    }
+
+    if (!mysql->options.reconnect ||
+        (mysql->server_status & SERVER_STATUS_IN_TRANS) || !mysql->host_info)
+    {
+        /* Allow reconnect next time */
+        mysql->server_status &= ~SERVER_STATUS_IN_TRANS;
+        my_set_error(mysql, CR_SERVER_GONE_ERROR, SQLSTATE_UNKNOWN, 0);
+        return(1);
+    }
+
+    mysql_init(&tmp_mysql);
+    tmp_mysql.free_me = 0;
+    tmp_mysql.options = mysql->options;
+    if (mysql->extension && mysql->extension->conn_hdlr)
+    {
+        tmp_mysql.extension->conn_hdlr = mysql->extension->conn_hdlr;
+        mysql->extension->conn_hdlr = 0;
+    }
+
+    /* don't reread options from configuration files */
+    tmp_mysql.options.my_cnf_group = tmp_mysql.options.my_cnf_file = NULL;
+    if (IS_MYSQL_ASYNC_ACTIVE(mysql))
+    {
+        ctxt = mysql->options.extension->async_context;
+        hook_data.orig_mysql = mysql;
+        hook_data.new_mysql = &tmp_mysql;
+        hook_data.orig_pvio = mysql->net.pvio;
+        my_context_install_suspend_resume_hook(ctxt, my_suspend_hook, &hook_data);
+    }
+
+    if (!mysql_real_connect(&tmp_mysql, mysql->host, mysql->user, mysql->passwd,
+        mysql->db, mysql->port, mysql->unix_socket,
+        mysql->client_flag | CLIENT_REMEMBER_OPTIONS) ||
+        mysql_set_character_set(&tmp_mysql, mysql->charset->csname, 0))
+    {
+        if (ctxt)
+            my_context_install_suspend_resume_hook(ctxt, NULL, NULL);
+        /* don't free options (CONC-118) */
+        memset(&tmp_mysql.options, 0, sizeof(struct st_mysql_options));
+        my_set_error(mysql, tmp_mysql.net.last_errno,
+            tmp_mysql.net.sqlstate,
+            tmp_mysql.net.last_error);
+        mysql_close(&tmp_mysql);
+        return(1);
+    }
+
+    for (; li_stmt; li_stmt = li_stmt->next)
+    {
+        MYSQL_STMT* stmt = (MYSQL_STMT*)li_stmt->data;
+
+        if (stmt->state != MYSQL_STMT_INITTED)
+        {
+            stmt->state = MYSQL_STMT_INITTED;
+            SET_CLIENT_STMT_ERROR(stmt, CR_SERVER_LOST, SQLSTATE_UNKNOWN, 0);
+        }
+    }
+
+    tmp_mysql.free_me = mysql->free_me;
+    tmp_mysql.stmts = mysql->stmts;
+    mysql->stmts = NULL;
+
+    if (ctxt)
+        my_context_install_suspend_resume_hook(ctxt, NULL, NULL);
+    /* Don't free options, we moved them to tmp_mysql */
+    memset(&mysql->options, 0, sizeof(mysql->options));
+    mysql->free_me = 0;
+    mysql_close(mysql);
+    *mysql = tmp_mysql;
+    mysql->net.pvio->mysql = mysql;
+    ma_net_clear(&mysql->net);
+    mysql->affected_rows = ~(unsigned long long) 0;
+    mysql->info = 0;
+    return(0);
+}
+
 void ma_invalidate_stmts(MYSQL *mysql, const char *function_name)
 {
   if (mysql->stmts)
   {
+/*
     LIST *li_stmt= mysql->stmts;
 
     for (; li_stmt; li_stmt= li_stmt->next)
@@ -1701,6 +1853,7 @@
       stmt->mysql= NULL;
       SET_CLIENT_STMT_ERROR(stmt, CR_STMT_CLOSED, SQLSTATE_UNKNOWN, function_name);
     }
+*/
     mysql->stmts= NULL;
   }
 }
@@ -1970,6 +2123,33 @@
   return;
 }
 
+void STDCALL
+mysql_close_no_command(MYSQL *mysql)
+{
+  if (mysql)                    /* Some simple safety */
+  {
+
+    if (mysql->methods) {
+            if (mysql->net.pvio) {
+                free_old_query(mysql);
+                mysql->status=MYSQL_STATUS_READY; /* Force command */
+            mysql->options.reconnect=0;
+                end_server(mysql);
+            }
+        }
+    mysql_close_memory(mysql);
+    mysql_close_options(mysql);
+    mysql->host_info=mysql->user=mysql->passwd=mysql->db=0;
+
+    /* Clear pointers for better safety */
+    bzero((char*) &mysql->options,sizeof(mysql->options));
+    mysql->net.pvio= 0;
+    if (mysql->free_me)
+      free(mysql);
+  }
+  return;
+}
+
 
 /**************************************************************************
 ** Do a query. If query returned rows, free old rows.
@@ -2036,6 +2216,8 @@
             old_pos= pos;
             si_type= (enum enum_session_state_type)net_field_length(&pos);
             switch(si_type) {
+            case SESSION_TRACK_GTIDS:
+              net_field_length(&pos); /* skip encoding */
             case SESSION_TRACK_SCHEMA:
             case SESSION_TRACK_STATE_CHANGE:
             case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:
@@ -3474,18 +3656,27 @@
   mariadb_get_charset_info(mysql, cs);
 }
 
-int STDCALL mysql_set_character_set(MYSQL *mysql, const char *csname)
+int STDCALL mysql_set_character_set(MYSQL *mysql, const char *csname, uint charsetnr)
 {
   const MARIADB_CHARSET_INFO *cs;
 
-  if (!csname)
+  if (!csname && !charsetnr)
     goto error;
 
-  if ((cs= mysql_find_charset_name(csname)))
-  {
-    char buff[64];
+  if (csname) {
+    cs = mysql_find_charset_name(csname);
+  } else {
+    cs = mysql_find_charset_nr(charsetnr); 
+  }
+  if (cs)
+  {
+    char buff[128];
+    if (csname) { // default behavior
+      snprintf(buff, 127, "SET NAMES %s", cs->csname);
+    } else {
+      snprintf(buff, 127, "SET NAMES %s COLLATE '%s'", cs->csname, cs->name);
+    }
 
-    snprintf(buff, 63, "SET NAMES %s", cs->csname);
     if (!mysql_real_query(mysql, buff, (unsigned long)strlen(buff)))
     {
       mysql->charset= cs;
@@ -3494,6 +3685,7 @@
   }
 
 error:
+  if (!cs)
   my_set_error(mysql, CR_CANT_READ_CHARSET, SQLSTATE_UNKNOWN,
                0, csname, "compiled_in");
   return(mysql->net.last_errno);
